<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Promise</title>
</head>
<body>




<script>

    api.sendStudentsCountToItKamasutra(20)
        .then(data => {
            console.log(data);
        });


/* let axios = {
get() {
let pr = new Promise((resolve, reject) => {
setTimeout(() => {
resolve({f: 1, sd: 45, message: 'Hello'})
}, 3000)
})
return pr
}
}

axios.get()
.then(data => console.log(data.message))
.then((message) => console.log(message))
.then((message2) => console.log(message2))


.then(() => {console.log(2)})
.catch(data => console.error(data))
.finally(() => {console.log("Thank")})*/


//ченинг
// let a = {
// sum(a, b) {
// console.log(a+b);
// return this
// }
// }
//
// a.sum(2, 3)
// a.sum(7, 3)
// a.sum(2, 4)


// внутрь Promise передаем колбэк-функцию, которая собственно и есть та логика, которую промис обещает выполнить.
// let myPromise = new Promise((resolve, reject) => {
// resolve(Math.random())
//
// });

// ниже по коду мы можем подписаться, на промис, чтобы он (промис) вызвал нашу функцию, когда он (промис) зарезолвится.Для этого передаём в метод then колбэк-функцию)

//промиссификация аллерта
/* let promis = new Promise((res, rej) => {
alert("Mrrrrrrrrr")
res()
})
promis.then()*/

/*const doAfter = (sec) => {
let myPromise = new Promise((resolve, reject) => {
setTimeout (() => {
resolve()
}, sec*1000)
});
return myPromise
}

doAfter(5).then(() => console.log('я сработал через 5 секунд'));
doAfter(3).then(() => console.log('а я сработал через 3 секунд'));
doAfter(10).then(() => console.log('я сработал через 10 секунд'));
*/
// myPromise.then((number) => {
// console.log(number);
// console.log(myPromise);
// })
// myPromise.then((number) => {
// console.log("myr: " + number);
// console.log(myPromise);
// })

</script>


</body>
</html>